/* automatically generated by rust-bindgen 0.71.1 */

pub const EDLIB_STATUS_OK: u32 = 0;
pub const EDLIB_STATUS_ERROR: u32 = 1;
pub const EDLIB_EDOP_MATCH: u32 = 0;
pub const EDLIB_EDOP_INSERT: u32 = 1;
pub const EDLIB_EDOP_DELETE: u32 = 2;
pub const EDLIB_EDOP_MISMATCH: u32 = 3;
#[doc = " Global method. This is the standard method.\n Useful when you want to find out how similar is first sequence to second sequence."]
pub const EdlibAlignMode_EDLIB_MODE_NW: EdlibAlignMode = 0;
#[doc = " Prefix method. Similar to global method, but with a small twist - gap at query end is not penalized.\n What that means is that deleting elements from the end of second sequence is \"free\"!\n For example, if we had \"AACT\" and \"AACTGGC\", edit distance would be 0, because removing \"GGC\" from the end\n of second sequence is \"free\" and does not count into total edit distance. This method is appropriate\n when you want to find out how well first sequence fits at the beginning of second sequence."]
pub const EdlibAlignMode_EDLIB_MODE_SHW: EdlibAlignMode = 1;
#[doc = " Infix method. Similar as prefix method, but with one more twist - gaps at query end and start are\n not penalized. What that means is that deleting elements from the start and end of second sequence is \"free\"!\n For example, if we had ACT and CGACTGAC, edit distance would be 0, because removing CG from the start\n and GAC from the end of second sequence is \"free\" and does not count into total edit distance.\n This method is appropriate when you want to find out how well first sequence fits at any part of\n second sequence.\n For example, if your second sequence was a long text and your first sequence was a sentence from that text,\n but slightly scrambled, you could use this method to discover how scrambled it is and where it fits in\n that text. In bioinformatics, this method is appropriate for aligning read to a sequence."]
pub const EdlibAlignMode_EDLIB_MODE_HW: EdlibAlignMode = 2;
#[doc = " Alignment methods - how should Edlib treat gaps before and after query?"]
pub type EdlibAlignMode = ::std::os::raw::c_uint;
#[doc = "!< Find edit distance and end locations."]
pub const EdlibAlignTask_EDLIB_TASK_DISTANCE: EdlibAlignTask = 0;
#[doc = "!< Find edit distance, end locations and start locations."]
pub const EdlibAlignTask_EDLIB_TASK_LOC: EdlibAlignTask = 1;
#[doc = "!< Find edit distance, end locations and start locations and alignment path."]
pub const EdlibAlignTask_EDLIB_TASK_PATH: EdlibAlignTask = 2;
#[doc = " Alignment tasks - what do you want Edlib to do?"]
pub type EdlibAlignTask = ::std::os::raw::c_uint;
#[doc = "!< Match: 'M', Insertion: 'I', Deletion: 'D', Mismatch: 'M'."]
pub const EdlibCigarFormat_EDLIB_CIGAR_STANDARD: EdlibCigarFormat = 0;
#[doc = "!< Match: '=', Insertion: 'I', Deletion: 'D', Mismatch: 'X'."]
pub const EdlibCigarFormat_EDLIB_CIGAR_EXTENDED: EdlibCigarFormat = 1;
#[doc = " Describes cigar format.\n @see http://samtools.github.io/hts-specs/SAMv1.pdf\n @see http://drive5.com/usearch/manual/cigar.html"]
pub type EdlibCigarFormat = ::std::os::raw::c_uint;
#[doc = " @brief Defines two given characters as equal."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EdlibEqualityPair {
    pub first: ::std::os::raw::c_char,
    pub second: ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EdlibEqualityPair"][::std::mem::size_of::<EdlibEqualityPair>() - 2usize];
    ["Alignment of EdlibEqualityPair"][::std::mem::align_of::<EdlibEqualityPair>() - 1usize];
    ["Offset of field: EdlibEqualityPair::first"]
        [::std::mem::offset_of!(EdlibEqualityPair, first) - 0usize];
    ["Offset of field: EdlibEqualityPair::second"]
        [::std::mem::offset_of!(EdlibEqualityPair, second) - 1usize];
};
#[doc = " @brief Configuration object for edlibAlign() function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EdlibAlignConfig {
    #[doc = " Set k to non-negative value to tell edlib that edit distance is not larger than k.\n Smaller k can significantly improve speed of computation.\n If edit distance is larger than k, edlib will set edit distance to -1.\n Set k to negative value and edlib will internally auto-adjust k until score is found."]
    pub k: ::std::os::raw::c_int,
    #[doc = " Alignment method.\n EDLIB_MODE_NW: global (Needleman-Wunsch)\n EDLIB_MODE_SHW: prefix. Gap after query is not penalized.\n EDLIB_MODE_HW: infix. Gaps before and after query are not penalized."]
    pub mode: EdlibAlignMode,
    #[doc = " Alignment task - tells Edlib what to calculate. Less to calculate, faster it is.\n EDLIB_TASK_DISTANCE - find edit distance and end locations of optimal alignment paths in target.\n EDLIB_TASK_LOC - find edit distance and start and end locations of optimal alignment paths in target.\n EDLIB_TASK_PATH - find edit distance, alignment path (and start and end locations of it in target)."]
    pub task: EdlibAlignTask,
    #[doc = " List of pairs of characters, where each pair defines two characters as equal.\n This way you can extend edlib's definition of equality (which is that each character is equal only\n to itself).\n This can be useful if you have some wildcard characters that should match multiple other characters,\n or e.g. if you want edlib to be case insensitive.\n Can be set to NULL if there are none."]
    pub additionalEqualities: *const EdlibEqualityPair,
    #[doc = " Number of additional equalities, which is non-negative number.\n 0 if there are none."]
    pub additionalEqualitiesLength: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EdlibAlignConfig"][::std::mem::size_of::<EdlibAlignConfig>() - 32usize];
    ["Alignment of EdlibAlignConfig"][::std::mem::align_of::<EdlibAlignConfig>() - 8usize];
    ["Offset of field: EdlibAlignConfig::k"][::std::mem::offset_of!(EdlibAlignConfig, k) - 0usize];
    ["Offset of field: EdlibAlignConfig::mode"]
        [::std::mem::offset_of!(EdlibAlignConfig, mode) - 4usize];
    ["Offset of field: EdlibAlignConfig::task"]
        [::std::mem::offset_of!(EdlibAlignConfig, task) - 8usize];
    ["Offset of field: EdlibAlignConfig::additionalEqualities"]
        [::std::mem::offset_of!(EdlibAlignConfig, additionalEqualities) - 16usize];
    ["Offset of field: EdlibAlignConfig::additionalEqualitiesLength"]
        [::std::mem::offset_of!(EdlibAlignConfig, additionalEqualitiesLength) - 24usize];
};
unsafe extern "C" {
    #[doc = " Helper method for easy construction of configuration object.\n @return Configuration object filled with given parameters."]
    pub fn edlibNewAlignConfig(
        k: ::std::os::raw::c_int,
        mode: EdlibAlignMode,
        task: EdlibAlignTask,
        additionalEqualities: *const EdlibEqualityPair,
        additionalEqualitiesLength: ::std::os::raw::c_int,
    ) -> EdlibAlignConfig;
}
unsafe extern "C" {
    #[doc = " @return Default configuration object, with following defaults:\n         k = -1, mode = EDLIB_MODE_NW, task = EDLIB_TASK_DISTANCE, no additional equalities."]
    pub fn edlibDefaultAlignConfig() -> EdlibAlignConfig;
}
#[doc = " Container for results of alignment done by edlibAlign() function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EdlibAlignResult {
    #[doc = " EDLIB_STATUS_OK or EDLIB_STATUS_ERROR. If error, all other fields will have undefined values."]
    pub status: ::std::os::raw::c_int,
    #[doc = " -1 if k is non-negative and edit distance is larger than k."]
    pub editDistance: ::std::os::raw::c_int,
    #[doc = " Array of zero-based positions in target 
     optimal alignment paths end.\n If gap after query is penalized, gap counts as part of query (NW), otherwise not.\n Set to NULL if edit distance is larger than k.\n If you do not free whole result object using edlibFreeAlignResult(), do not forget to use free()."]
    pub endLocations: *mut ::std::os::raw::c_int,
    #[doc = " Array of zero-based positions in target where optimal alignment paths start,\n they correspond to endLocations.\n If gap before query is penalized, gap counts as part of query (NW), otherwise not.\n Set to NULL if not calculated or if edit distance is larger than k.\n If you do not free whole result object using edlibFreeAlignResult(), do not forget to use free()."]
    pub startLocations: *mut ::std::os::raw::c_int,
    #[doc = " Number of end (and start) locations."]
    pub numLocations: ::std::os::raw::c_int,
    #[doc = " Alignment is found for first pair of start and end locations.\n Set to NULL if not calculated.\n Alignment is sequence of numbers: 0, 1, 2, 3.\n 0 stands for match.\n 1 stands for insertion to target.\n 2 stands for insertion to query.\n 3 stands for mismatch.\n Alignment aligns query to target from beginning of query till end of query.\n If gaps are not penalized, they are not in alignment.\n If you do not free whole result object using edlibFreeAlignResult(), do not forget to use free()."]
    pub alignment: *mut ::std::os::raw::c_uchar,
    #[doc = " Length of alignment."]
    pub alignmentLength: ::std::os::raw::c_int,
    #[doc = " Number of different characters in query and target together."]
    pub alphabetLength: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EdlibAlignResult"][::std::mem::size_of::<EdlibAlignResult>() - 48usize];
    ["Alignment of EdlibAlignResult"][::std::mem::align_of::<EdlibAlignResult>() - 8usize];
    ["Offset of field: EdlibAlignResult::status"]
        [::std::mem::offset_of!(EdlibAlignResult, status) - 0usize];
    ["Offset of field: EdlibAlignResult::editDistance"]
        [::std::mem::offset_of!(EdlibAlignResult, editDistance) - 4usize];
    ["Offset of field: EdlibAlignResult::endLocations"]
        [::std::mem::offset_of!(EdlibAlignResult, endLocations) - 8usize];
    ["Offset of field: EdlibAlignResult::startLocations"]
        [::std::mem::offset_of!(EdlibAlignResult, startLocations) - 16usize];
    ["Offset of field: EdlibAlignResult::numLocations"]
        [::std::mem::offset_of!(EdlibAlignResult, numLocations) - 24usize];
    ["Offset of field: EdlibAlignResult::alignment"]
        [::std::mem::offset_of!(EdlibAlignResult, alignment) - 32usize];
    ["Offset of field: EdlibAlignResult::alignmentLength"]
        [::std::mem::offset_of!(EdlibAlignResult, alignmentLength) - 40usize];
    ["Offset of field: EdlibAlignResult::alphabetLength"]
        [::std::mem::offset_of!(EdlibAlignResult, alphabetLength) - 44usize];
};
unsafe extern "C" {
    #[doc = " Frees memory in EdlibAlignResult that was allocated by edlib.\n If you do not use it, make sure to free needed members manually using free()."]
    pub fn edlibFreeAlignResult(result: EdlibAlignResult);
}
unsafe extern "C" {
    #[doc = " Aligns two sequences (query and target) using edit distance (levenshtein distance).\n Through config parameter, this function supports different alignment methods (global, prefix, infix),\n as well as different modes of search (tasks).\n It always returns edit distance and end locations of optimal alignment in target.\n It optionally returns start locations of optimal alignment in target and alignment path,\n if you choose appropriate tasks.\n @param [in] query  First sequence.\n @param [in] queryLength  Number of characters in first sequence.\n @param [in] target  Second sequence.\n @param [in] targetLength  Number of characters in second sequence.\n @param [in] config  Additional alignment parameters, like alignment method and wanted results.\n @return  Result of alignment, which can contain edit distance, start and end locations and alignment path.\n          Make sure to clean up the object using edlibFreeAlignResult() or by manually freeing needed members."]
    pub fn edlibAlign(
        query: *const ::std::os::raw::c_char,
        queryLength: ::std::os::raw::c_int,
        target: *const ::std::os::raw::c_char,
        targetLength: ::std::os::raw::c_int,
        config: EdlibAlignConfig,
    ) -> EdlibAlignResult;
}
unsafe extern "C" {
    #[doc = " Builds cigar string from given alignment sequence.\n @param [in] alignment  Alignment sequence.\n     0 stands for match.\n     1 stands for insertion to target.\n     2 stands for insertion to query.\n     3 stands for mismatch.\n @param [in] alignmentLength\n @param [in] cigarFormat  Cigar will be returned in specified format.\n @return Cigar string.\n     I stands for insertion.\n     D stands for deletion.\n     X stands for mismatch. (used only in extended format)\n     = stands for match. (used only in extended format)\n     M stands for (mis)match. (used only in standard format)\n     String is null terminated.\n     Needed memory is allocated and given pointer is set to it.\n     Do not forget to free it later using free()!"]
    pub fn edlibAlignmentToCigar(
        alignment: *const ::std::os::raw::c_uchar,
        alignmentLength: ::std::os::raw::c_int,
        cigarFormat: EdlibCigarFormat,
    ) -> *mut ::std::os::raw::c_char;
}
